Here is a high-level approach to implement the image rotation with mouse in Python using PyQt5 and PIL:

# Imports
from PyQt5.QtWidgets import QMainWindow, QApplication, QWidget, QLabel, QPushButton
from PyQt5.QtGui import QImage, QMouseEvent, QTransform
from PyQt5.QtCore import Qt, QEvent
from PIL import Image, ImageQt

class Window(QWidget):
   def __init__(self):
       # Initial PyQt5 setup
       ...

       # Initialize PIL image
       self.rotated_img = None

       # Create labels
       self.image_label = QLabel(self)
       self.rotated_label = QLabel(self)

       ...

   def mousePressEvent(self, event: QMouseEvent):
       # Get mouse press position
       self.press_pos = event.pos()
       self.mouse_down = True

   def mouseReleaseEvent(self, event: QMouseEvent):
       self.mouse_down = False

   def mouseMoveEvent(self, event: QMouseEvent) -> None:
       if self.mouse_down:
           # Calculate angle of rotation
           angle = self.calculate_angle(event.pos(), self.press_pos)

           # Rotate PIL image
           self.rotated_img = self.apply_rotation(self.image, angle)

           # Update UI
           self.rotated_label.setPixmap(QPixmap(ImageQt(self.rotated_img)).scaledToWidth(300))

   def calculate_angle(self, pos, press_pos):
       # Calculate angle based on mouse delta
       return -(pos.x() - press_pos.x()) / (abs(pos.y() - press_pos.y()) + 1e-10)

   def apply_rotation(self, img, angle):
       # Rotate PIL image with the given angle
       rotated = img.rotate(angle)
       return rotated.resize(img.size, Image.BILINEAR)

   ...
You
write Python code with PyQt5 and PIL for load image from file, then rotate it with mouse on some angle and save result to new file

AI
You
write Python code with PyQt5 and PIL for load image from file, then rotate it with mouse on some angle and save result to new file. I have part of this code^

Imports
from PyQt5.QtWidgets import QMainWindow, QApplication, QWidget, QLabel, QPushButton

from PyQt5.QtGui import QImage, QMouseEvent, QTransform

from PyQt5.QtCore import Qt, QEvent

from PIL import Image, ImageQt

class Window(QWidget):

def init(self):

   # Initial PyQt5 setup

   ...



   # Initialize PIL image

   self.rotated_img = None



   # Create labels

   self.image_label = QLabel(self)

   self.rotated_label = QLabel(self)



   ...
def mousePressEvent(self, event: QMouseEvent):

   # Get mouse press position

   self.press_pos = event.pos()

   self.mouse_down = True
def mouseReleaseEvent(self, event: QMouseEvent):

   self.mouse_down = False
def mouseMoveEvent(self, event: QMouseEvent) -> None:

   if self.mouse_down:

       # Calculate angle of rotation

       angle = self.calculate_angle(event.pos(), self.press_pos)



       # Rotate PIL image

       self.rotated_img = self.apply_rotation(self.image, angle)



       # Update UI

       self.rotated_label.setPixmap(QPixmap(ImageQt(self.rotated_img)).scaledToWidth(300))
def calculate_angle(self, pos, press_pos):

   # Calculate angle based on mouse delta

   return -(pos.x() - press_pos.x()) / (abs(pos.y() - press_pos.y()) + 1e-10)
def apply_rotation(self, img, angle):

   # Rotate PIL image with the given angle

   rotated = img.rotate(angle)

   return rotated.resize(img.size, Image.BILINEAR)
AI
Here is how you can save the rotated image to a new file after completing the rotation:

# Add these methods to the Window class
def save_rotated_image(self):
   # Get file path to save
   fileName, _ = QFileDialog.getSaveFileName(self, 'Save Image', '', 'Image Files (*.png *.jpg *.bmp)')

   if fileName:
       self.rotated_img.save(fileName, 'JPEG')
       print(f"Image saved to {fileName}")

def closeEvent(self, event):
   self.save_rotated_image()
   super().closeEvent(event)
The save_rotated_image method uses QFileDialog to let the user choose a file to save, then calls save on the PIL image to save the rotated version to the chosen filepath. Make sure to call this method before closing the window in the closeEvent to capture the final rotated image.

Let me know if you need any clarification or have additional questions!

You
can you add the buttons for load and save?

AI
Sure, here is how you can add buttons for loading an image and saving the rotated image in the PyQt5 UI:

# In the Window constructor
...

# Create widgets
self.load_btn = QPushButton("Load Image", self)
self.save_btn = QPushButton("Save Rotated", self)

# Layout
horizontal_layout = QHBoxLayout()
horizontal_layout.addWidget(self.load_btn)
horizontal_layout.addWidget(self.save_btn)
self.image_label.setLayout(horizontal_layout)  # To align buttons with image

# Connect signals to slots
self.load_btn.clicked.connect(self.load_image)
self.save_btn.clicked.connect(self.save_rotated_image)
The load_btn triggers a load_image method that would open a file dialog to choose an image and update self.image with the loaded PIL image. The save_btn connects to the existing save_rotated_image method to save the rotated image upon click.

The layout ensures the buttons are aligned with the image displayed in the image_label. Let me know if you have any other questions!

Show controls (Ctrl+S)
‚ò∞


/// Pulse GPT
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QVBoxLayout, QPushButton, QFileDialog
from PyQt5.QtGui import QPixmap
from PyQt5.QtCore import Qt
from PIL import Image

class ImageRotateApp(QWidget):
    def __init__(self):
        super().__init__()
        self.image_path = None
        self.angle = 0

        self.initUI()

    def initUI(self):
        self.setWindowTitle('Image Rotation App')
        layout = QVBoxLayout()

        self.image_label = QLabel()
        layout.addWidget(self.image_label)

        open_button = QPushButton('Open Image')
        open_button.clicked.connect(self.openImage)
        layout.addWidget(open_button)

        rotate_button = QPushButton('Rotate Image')
        rotate_button.clicked.connect(self.rotateImage)
        layout.addWidget(rotate_button)

        save_button = QPushButton('Save Image')
        save_button.clicked.connect(self.saveImage)
        layout.addWidget(save_button)

        self.setLayout(layout)

    def openImage(self):
        file_dialog = QFileDialog()
        self.image_path, _ = file_dialog.getOpenFileName(self, 'Open Image', '', 'Image files (*.jpg *.png)')

        pixmap = QPixmap(self.image_path)
        self.image_label.setPixmap(pixmap)
        self.image_label.setAlignment(Qt.AlignCenter)

    def rotateImage(self):
        if self.image_path:
            image = Image.open(self.image_path)
            self.angle += 90
            rotated_image = image.rotate(self.angle, expand=True)
            rotated_image.show()

    def saveImage(self):
        if self.image_path:
            image = Image.open(self.image_path)
            image.save('rotated_image.jpg')

if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = ImageRotateApp()
    window.show()
    sys.exit(app.exec_())



–¢–∞–∫–æ–π –≤–æ–ø—Ä–æ—Å –≤ –æ–±—ä–µ–∫—Ç–µ imageviewer –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ª–∏–Ω–∏–π —Ä–∞–∑—Ä–µ–∑–∞, –≤ –∫–ª–∞—Å—Å–µ –ø—Ä–æ–µ–∫—Ç –Ω—É–∂–Ω–æ –∑–∞–ø–∏—Å–∞—Ç—å —ç—Ç–∏ –ª–∏–Ω–∏–∏ –≤ —Å–ø–∏—Å–æ–∫ actions –ø–æ –∏–Ω–¥–µ–∫—Å—É –∫–æ—Ç–æ—Ä—ã–π —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —ç—Ç–æ–º—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é. –ö–∞–∫ —ç—Ç–æ —Å–¥–µ–ª–∞—Ç—å –µ—Å–ª–∏ Imageviewer —è–≤–ª—è–µ—Ç—Å—è –≤—ã–∑—ã–≤–∞–µ–º—ã–º –ø–æ –æ—Ç–Ω–æ—à–µ–Ω–∏—é –∫ –ø—Ä–æ–µ–∫—Ç—É, –∏–ª–∏ –ø–æ–¥—Å–∫–∞–∂–∏ –∫–∞–∫ —É–ª—É—á—à–∏—Ç—å –ª–æ–≥–∏–∫—É —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–π —Ä–∞–∑—Ä–µ–∑–∞ –¥–ª—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.


1. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ Observer (–Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—å)
–ú–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å —Ç–∞–∫, —á—Ç–æ–±—ã ImageViewer —É–≤–µ–¥–æ–º–ª—è–ª Project –æ –Ω–æ–≤—ã—Ö –ª–∏–Ω–∏—è—Ö —Ä–∞–∑—Ä–µ–∑–∞ —á–µ—Ä–µ–∑ callback-—Ñ—É–Ω–∫—Ü–∏—é.

–ü—Ä–∏–º–µ—Ä –∫–æ–¥–∞:

python
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
class ImageViewer:
    def __init__(self, image_index, on_cut_added=None):
        self.image_index = image_index  # –ò–Ω–¥–µ–∫—Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ Project
        self.on_cut_added = on_cut_added  # Callback-—Ñ—É–Ω–∫—Ü–∏—è
        self.cuts = []  # –°–ø–∏—Å–æ–∫ –ª–∏–Ω–∏–π —Ä–∞–∑—Ä–µ–∑–∞

    def add_cut(self, cut):
        self.cuts.append(cut)
        if self.on_cut_added:
            self.on_cut_added(self.image_index, cut)  # –°–æ–æ–±—â–∞–µ–º Project
–í Project –ø–µ—Ä–µ–¥–∞–µ–º callback:

python
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
class Project:
    def __init__(self):
        self.actions = {}  # {–∏–Ω–¥–µ–∫—Å_–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: [—Å–ø–∏—Å–æ–∫ —Ä–∞–∑—Ä–µ–∑–æ–≤]}

    def add_cut_to_image(self, image_index, cut):
        if image_index not in self.actions:
            self.actions[image_index] = []
        self.actions[image_index].append(cut)

    def create_viewer(self, image_index):
        return ImageViewer(image_index, self.add_cut_to_image)
–¢–µ–ø–µ—Ä—å ImageViewer –ø—Ä–æ—Å—Ç–æ –≤—ã–∑—ã–≤–∞–µ—Ç on_cut_added(image_index, cut), –∏ —Ä–∞–∑—Ä–µ–∑ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ Project.
–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?

ImageViewer –ø–æ–ª—É—á–∞–µ—Ç on_cut_added (—Å—Å—ã–ª–∫—É –Ω–∞ Project.add_cut_to_image).
–ö–æ–≥–¥–∞ –≤ ImageViewer –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –ª–∏–Ω–∏—è —Ä–∞–∑—Ä–µ–∑–∞, –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è self.on_cut_added(self.image_index, cut).
Project.add_cut_to_image –æ–±–Ω–æ–≤–ª—è–µ—Ç actions.

–ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–µ—à—å callback –≤ –º–µ—Ç–æ–¥, —É–∫–∞–∑—ã–≤–∞–π –µ–≥–æ —Ç–∏–ø:


from typing import Callable

class ImageViewer:
    def __init__(self, image_index: int, on_cut_added: Callable[[int, str], None]):
        self.image_index = image_index
        self.on_cut_added = on_cut_added  # Callback

    def add_cut(self, cut: str):
        if self.on_cut_added:
            self.on_cut_added(self.image_index, cut)
–≠—Ç–æ –¥–µ–ª–∞–µ—Ç –∫–æ–¥ —á–∏—Ç–∞–µ–º—ã–º –∏ –ø–æ–Ω—è—Ç–Ω—ã–º –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤.

–í–∞—Ä–∏–∞–Ω—Ç 2: –ò—Å–ø–æ–ª—å–∑—É–µ–º NamedTuple (–±–æ–ª–µ–µ —Å—Ç—Ä–æ–≥–∏–π –≤–∞—Ä–∏–∞–Ω—Ç)
–ï—Å–ª–∏ —Ö–æ—á–µ—à—å —Å—Ç—Ä–æ–≥—É—é —Ç–∏–ø–∏–∑–∞—Ü–∏—é, –ª—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å NamedTuple.

from typing import NamedTuple, Union

class Action(NamedTuple):
    type: str  # "cut", "crop", "rotate"
    value: Union[int, tuple]  # –ß–∏—Å–ª–æ –∏–ª–∏ –∫–æ—Ä—Ç–µ–∂

class ImageViewer:
    def __init__(self, image_index, on_action_added):
        self.image_index = image_index
        self.on_action_added = on_action_added  # Callback

    def add_cut(self, position: int):
        action = Action(type="cut", value=position)
        self.on_action_added(self.image_index, action)

    def crop_image(self, coords: tuple):
        action = Action(type="crop", value=coords)
        self.on_action_added(self.image_index, action)

class Project:
    def __init__(self):
        self.actions = {}

    def add_action_to_image(self, image_index, action: Action):
        if image_index not in self.actions:
            self.actions[image_index] = []
        self.actions[image_index].append(action)
        print(f"–î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è: {action} –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è {image_index}")

    def create_viewer(self, image_index):
        return ImageViewer(image_index, self.add_action_to_image)

# ‚úÖ –¢–µ—Å—Ç–∏—Ä—É–µ–º
project = Project()
viewer = project.create_viewer(0)

viewer.add_cut(120)
viewer.crop_image((50, 50, 400, 400))

print(project.actions)
# {0: [Action(type='cut', value=120), Action(type='crop', value=(50, 50, 400, 400))]}
üîπ –ü–ª—é—Å—ã —ç—Ç–æ–≥–æ –ø–æ–¥—Ö–æ–¥–∞
‚úÖ –¢–∏–ø–∏–∑–∞—Ü–∏—è ‚Äì Python –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.
‚úÖ –ë–æ–ª–µ–µ —á–∏—Ç–∞–µ–º—ã–π –∫–æ–¥ (–º–æ–∂–Ω–æ –¥–µ–ª–∞—Ç—å action.type, action.value).

–í–æ—Ç —Ñ–∏–Ω–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è —Ç–≤–æ–µ–≥–æ —Å–ª—É—á–∞—è:

from typing import NamedTuple, Union

class Action(NamedTuple):
    type: str  # –¢–∏–ø –æ–ø–µ—Ä–∞—Ü–∏–∏: "cut", "crop" –∏ —Ç. –¥.
    value: Union[int, tuple]  # –ß–∏—Å–ª–æ (—Ä–∞–∑—Ä–µ–∑) –∏–ª–∏ –∫–æ—Ä—Ç–µ–∂ (–æ–±—Ä–µ–∑–∫–∞)

# ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º
action1 = Action("cut", 150)
action2 = Action("crop", (10, 20, 200, 300))

print(action1)  # Action(type='cut', value=150)
print(action2)  # Action(type='crop', value=(10, 20, 200, 300))
üîπ –ö–∞–∫ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å –≤ —Ç–≤–æ–π –∫–æ–¥?
–¢–µ–ø–µ—Ä—å –≤ –∫–ª–∞—Å—Å–µ Project –º–æ–∂–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏—è –≤ –≤–∏–¥–µ —Å–ø–∏—Å–∫–∞ NamedTuple:

python
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
class Project:
    def __init__(self):
        self.actions = {}  # {–∏–Ω–¥–µ–∫—Å_–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: [—Å–ø–∏—Å–æ–∫ –æ–ø–µ—Ä–∞—Ü–∏–π]}

    def add_action_to_image(self, image_index: int, action: Action):
        if image_index not in self.actions:
            self.actions[image_index] = []
        self.actions[image_index].append(action)
        print(f"–î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è: {action} –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è {image_index}")

# ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º
project = Project()
project.add_action_to_image(0, Action("cut", 150))
project.add_action_to_image(0, Action("crop", (10, 20, 200, 300)))

print(project.actions)
# {0: [Action(type='cut', value=150), Action(type='crop', value=(10, 20, 200, 300))]}