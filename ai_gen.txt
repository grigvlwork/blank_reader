Here is a high-level approach to implement the image rotation with mouse in Python using PyQt5 and PIL:

# Imports
from PyQt5.QtWidgets import QMainWindow, QApplication, QWidget, QLabel, QPushButton
from PyQt5.QtGui import QImage, QMouseEvent, QTransform
from PyQt5.QtCore import Qt, QEvent
from PIL import Image, ImageQt

class Window(QWidget):
   def __init__(self):
       # Initial PyQt5 setup
       ...

       # Initialize PIL image
       self.rotated_img = None

       # Create labels
       self.image_label = QLabel(self)
       self.rotated_label = QLabel(self)

       ...

   def mousePressEvent(self, event: QMouseEvent):
       # Get mouse press position
       self.press_pos = event.pos()
       self.mouse_down = True

   def mouseReleaseEvent(self, event: QMouseEvent):
       self.mouse_down = False

   def mouseMoveEvent(self, event: QMouseEvent) -> None:
       if self.mouse_down:
           # Calculate angle of rotation
           angle = self.calculate_angle(event.pos(), self.press_pos)

           # Rotate PIL image
           self.rotated_img = self.apply_rotation(self.image, angle)

           # Update UI
           self.rotated_label.setPixmap(QPixmap(ImageQt(self.rotated_img)).scaledToWidth(300))

   def calculate_angle(self, pos, press_pos):
       # Calculate angle based on mouse delta
       return -(pos.x() - press_pos.x()) / (abs(pos.y() - press_pos.y()) + 1e-10)

   def apply_rotation(self, img, angle):
       # Rotate PIL image with the given angle
       rotated = img.rotate(angle)
       return rotated.resize(img.size, Image.BILINEAR)

   ...
You
write Python code with PyQt5 and PIL for load image from file, then rotate it with mouse on some angle and save result to new file

AI
You
write Python code with PyQt5 and PIL for load image from file, then rotate it with mouse on some angle and save result to new file. I have part of this code^

Imports
from PyQt5.QtWidgets import QMainWindow, QApplication, QWidget, QLabel, QPushButton

from PyQt5.QtGui import QImage, QMouseEvent, QTransform

from PyQt5.QtCore import Qt, QEvent

from PIL import Image, ImageQt

class Window(QWidget):

def init(self):

   # Initial PyQt5 setup

   ...



   # Initialize PIL image

   self.rotated_img = None



   # Create labels

   self.image_label = QLabel(self)

   self.rotated_label = QLabel(self)



   ...
def mousePressEvent(self, event: QMouseEvent):

   # Get mouse press position

   self.press_pos = event.pos()

   self.mouse_down = True
def mouseReleaseEvent(self, event: QMouseEvent):

   self.mouse_down = False
def mouseMoveEvent(self, event: QMouseEvent) -> None:

   if self.mouse_down:

       # Calculate angle of rotation

       angle = self.calculate_angle(event.pos(), self.press_pos)



       # Rotate PIL image

       self.rotated_img = self.apply_rotation(self.image, angle)



       # Update UI

       self.rotated_label.setPixmap(QPixmap(ImageQt(self.rotated_img)).scaledToWidth(300))
def calculate_angle(self, pos, press_pos):

   # Calculate angle based on mouse delta

   return -(pos.x() - press_pos.x()) / (abs(pos.y() - press_pos.y()) + 1e-10)
def apply_rotation(self, img, angle):

   # Rotate PIL image with the given angle

   rotated = img.rotate(angle)

   return rotated.resize(img.size, Image.BILINEAR)
AI
Here is how you can save the rotated image to a new file after completing the rotation:

# Add these methods to the Window class
def save_rotated_image(self):
   # Get file path to save
   fileName, _ = QFileDialog.getSaveFileName(self, 'Save Image', '', 'Image Files (*.png *.jpg *.bmp)')

   if fileName:
       self.rotated_img.save(fileName, 'JPEG')
       print(f"Image saved to {fileName}")

def closeEvent(self, event):
   self.save_rotated_image()
   super().closeEvent(event)
The save_rotated_image method uses QFileDialog to let the user choose a file to save, then calls save on the PIL image to save the rotated version to the chosen filepath. Make sure to call this method before closing the window in the closeEvent to capture the final rotated image.

Let me know if you need any clarification or have additional questions!

You
can you add the buttons for load and save?

AI
Sure, here is how you can add buttons for loading an image and saving the rotated image in the PyQt5 UI:

# In the Window constructor
...

# Create widgets
self.load_btn = QPushButton("Load Image", self)
self.save_btn = QPushButton("Save Rotated", self)

# Layout
horizontal_layout = QHBoxLayout()
horizontal_layout.addWidget(self.load_btn)
horizontal_layout.addWidget(self.save_btn)
self.image_label.setLayout(horizontal_layout)  # To align buttons with image

# Connect signals to slots
self.load_btn.clicked.connect(self.load_image)
self.save_btn.clicked.connect(self.save_rotated_image)
The load_btn triggers a load_image method that would open a file dialog to choose an image and update self.image with the loaded PIL image. The save_btn connects to the existing save_rotated_image method to save the rotated image upon click.

The layout ensures the buttons are aligned with the image displayed in the image_label. Let me know if you have any other questions!

Show controls (Ctrl+S)
☰


/// Pulse GPT
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QVBoxLayout, QPushButton, QFileDialog
from PyQt5.QtGui import QPixmap
from PyQt5.QtCore import Qt
from PIL import Image

class ImageRotateApp(QWidget):
    def __init__(self):
        super().__init__()
        self.image_path = None
        self.angle = 0

        self.initUI()

    def initUI(self):
        self.setWindowTitle('Image Rotation App')
        layout = QVBoxLayout()

        self.image_label = QLabel()
        layout.addWidget(self.image_label)

        open_button = QPushButton('Open Image')
        open_button.clicked.connect(self.openImage)
        layout.addWidget(open_button)

        rotate_button = QPushButton('Rotate Image')
        rotate_button.clicked.connect(self.rotateImage)
        layout.addWidget(rotate_button)

        save_button = QPushButton('Save Image')
        save_button.clicked.connect(self.saveImage)
        layout.addWidget(save_button)

        self.setLayout(layout)

    def openImage(self):
        file_dialog = QFileDialog()
        self.image_path, _ = file_dialog.getOpenFileName(self, 'Open Image', '', 'Image files (*.jpg *.png)')

        pixmap = QPixmap(self.image_path)
        self.image_label.setPixmap(pixmap)
        self.image_label.setAlignment(Qt.AlignCenter)

    def rotateImage(self):
        if self.image_path:
            image = Image.open(self.image_path)
            self.angle += 90
            rotated_image = image.rotate(self.angle, expand=True)
            rotated_image.show()

    def saveImage(self):
        if self.image_path:
            image = Image.open(self.image_path)
            image.save('rotated_image.jpg')

if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = ImageRotateApp()
    window.show()
    sys.exit(app.exec_())



Такой вопрос в объекте imageviewer происходит добавление на изображение линий разреза, в классе проект нужно записать эти линии в список actions по индексу который соответствует этому изображению. Как это сделать если Imageviewer является вызываемым по отношению к проекту, или подскажи как улучшить логику хранения позиций разреза для нескольких изображений.


1. Использование Observer (наблюдатель)
Можно сделать так, чтобы ImageViewer уведомлял Project о новых линиях разреза через callback-функцию.

Пример кода:

python
Копировать
Редактировать
class ImageViewer:
    def __init__(self, image_index, on_cut_added=None):
        self.image_index = image_index  # Индекс изображения в Project
        self.on_cut_added = on_cut_added  # Callback-функция
        self.cuts = []  # Список линий разреза

    def add_cut(self, cut):
        self.cuts.append(cut)
        if self.on_cut_added:
            self.on_cut_added(self.image_index, cut)  # Сообщаем Project
В Project передаем callback:

python
Копировать
Редактировать
class Project:
    def __init__(self):
        self.actions = {}  # {индекс_изображения: [список разрезов]}

    def add_cut_to_image(self, image_index, cut):
        if image_index not in self.actions:
            self.actions[image_index] = []
        self.actions[image_index].append(cut)

    def create_viewer(self, image_index):
        return ImageViewer(image_index, self.add_cut_to_image)
Теперь ImageViewer просто вызывает on_cut_added(image_index, cut), и разрез сохраняется в Project.
Как это работает?

ImageViewer получает on_cut_added (ссылку на Project.add_cut_to_image).
Когда в ImageViewer добавляется линия разреза, вызывается self.on_cut_added(self.image_index, cut).
Project.add_cut_to_image обновляет actions.

Если передаешь callback в метод, указывай его тип:


from typing import Callable

class ImageViewer:
    def __init__(self, image_index: int, on_cut_added: Callable[[int, str], None]):
        self.image_index = image_index
        self.on_cut_added = on_cut_added  # Callback

    def add_cut(self, cut: str):
        if self.on_cut_added:
            self.on_cut_added(self.image_index, cut)
Это делает код читаемым и понятным для разработчиков.

Вариант 2: Используем NamedTuple (более строгий вариант)
Если хочешь строгую типизацию, лучше использовать NamedTuple.

from typing import NamedTuple, Union

class Action(NamedTuple):
    type: str  # "cut", "crop", "rotate"
    value: Union[int, tuple]  # Число или кортеж

class ImageViewer:
    def __init__(self, image_index, on_action_added):
        self.image_index = image_index
        self.on_action_added = on_action_added  # Callback

    def add_cut(self, position: int):
        action = Action(type="cut", value=position)
        self.on_action_added(self.image_index, action)

    def crop_image(self, coords: tuple):
        action = Action(type="crop", value=coords)
        self.on_action_added(self.image_index, action)

class Project:
    def __init__(self):
        self.actions = {}

    def add_action_to_image(self, image_index, action: Action):
        if image_index not in self.actions:
            self.actions[image_index] = []
        self.actions[image_index].append(action)
        print(f"Добавлена операция: {action} для изображения {image_index}")

    def create_viewer(self, image_index):
        return ImageViewer(image_index, self.add_action_to_image)

# ✅ Тестируем
project = Project()
viewer = project.create_viewer(0)

viewer.add_cut(120)
viewer.crop_image((50, 50, 400, 400))

print(project.actions)
# {0: [Action(type='cut', value=120), Action(type='crop', value=(50, 50, 400, 400))]}
🔹 Плюсы этого подхода
✅ Типизация – Python проверяет, что передаются правильные данные.
✅ Более читаемый код (можно делать action.type, action.value).

Вот финальная реализация для твоего случая:

from typing import NamedTuple, Union

class Action(NamedTuple):
    type: str  # Тип операции: "cut", "crop" и т. д.
    value: Union[int, tuple]  # Число (разрез) или кортеж (обрезка)

# ✅ Используем
action1 = Action("cut", 150)
action2 = Action("crop", (10, 20, 200, 300))

print(action1)  # Action(type='cut', value=150)
print(action2)  # Action(type='crop', value=(10, 20, 200, 300))
🔹 Как интегрировать в твой код?
Теперь в классе Project можно хранить действия в виде списка NamedTuple:

python
Копировать
Редактировать
class Project:
    def __init__(self):
        self.actions = {}  # {индекс_изображения: [список операций]}

    def add_action_to_image(self, image_index: int, action: Action):
        if image_index not in self.actions:
            self.actions[image_index] = []
        self.actions[image_index].append(action)
        print(f"Добавлена операция: {action} для изображения {image_index}")

# ✅ Используем
project = Project()
project.add_action_to_image(0, Action("cut", 150))
project.add_action_to_image(0, Action("crop", (10, 20, 200, 300)))

print(project.actions)
# {0: [Action(type='cut', value=150), Action(type='crop', value=(10, 20, 200, 300))]}